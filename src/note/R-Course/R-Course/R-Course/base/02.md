---
title: 02-R 语言编程
icon: cib-r
date: 2023-11-08 16:04:40
author: AI悦创
isOriginal: true
category: 
    - 1v1
    - R 语言一对一辅导
    - 数据分析一对一辅导
    - 数据分析一对一教学
    - 留学生辅导
    - R
    - 留学生作业辅导
tag:
    - 1v1
    - R 语言一对一辅导
    - 数据分析一对一辅导
    - 数据分析一对一教学
    - 留学生辅导
    - R
    - 留学生作业辅导
sticky: false
star: false
article: true
timeline: true
image: false
navbar: true
sidebarIcon: true
headerDepth: 5
comment: true
lastUpdated: true
editLink: false
backToTop: true
toc: true
---

## 1. 决策

### 1.1 if 条件语句

在许多情况下，你需要根据条件做出决定。

为此，可以使用 **if** 语句。

例如：

```r
x <- 24
if(x > 10){
    print( "x is greater than 10")
}
```

如你所见，**if** 关键字后面是括号中的条件和大括号中的代码块，如果条件为 **TRUE**，则执行该代码块。

> 如果 if 语句的条件为 **FALSE**，则大括号中的代码将不会运行。

**【填空题】小测**

将下面代码填空完整使得可以创建有效的 if 语句。

```r
logged_in = TRUE
___ (logged_in == TRUE___{
    print("Welcome")
___
```

### 1.2 else 语句

如果需要在 **if** 语句的条件为 **FALSE** 时运行代码，可以使用 **else** 语句：

```r
x <- 42
if(x >= 100){
    print( "x is big")
} else {
    print( "x is less than 100")
}
```

### 1.3 else if 语句

如果需要多个检查，可以使用多个 **else if** 语句。

例如，让我们输出给定数字的英文版本：

```r
num <- 3
if(num == 1){
    print("one")
} else if (num == 2){
    print("Two")
} else if (num == 3){
    print("Three")
} else {
    print("Something else")
}
```

**【单选题】小测**

下面这段代码的输出是什么？

```r
x <- 7
if(x == 0) {
    print("Zero")
} else if(x %% 2 == 0) {
    print("Even")
} else {
    print("Odd")
}
```

## 2. 逻辑运算符

在 R 语言中，逻辑运算符用于比较值和表达式。以下是 R 语言中常用的逻辑运算符：

- `&`：逻辑与（AND）运算符，如果两个值都为 TRUE，则返回 TRUE。
- `|`：逻辑或（OR）运算符，如果至少一个值为 TRUE，则返回 TRUE。
- `!`：逻辑非（NOT）运算符，对逻辑值取反。
- `&&`：短路逻辑与（AND）运算符，仅当第一个值为 TRUE 时才检查第二个值。
- `||`：短路逻辑或（OR）运算符，仅当第一个值为 FALSE 时才检查第二个值。
- `==`：等于运算符，如果两个值相等，则返回 TRUE。
- `!=`：不等于运算符，如果两个值不相等，则返回 TRUE。
- `<`：小于运算符，如果左边的值小于右边的值，则返回 TRUE。
- `>`：大于运算符，如果左边的值大于右边的值，则返回 TRUE。
- `<=`：小于或等于运算符，如果左边的值小于或等于右边的值，则返回 TRUE。
- `>=`：大于或等于运算符，如果左边的值大于或等于右边的值，则返回 TRUE。

这些运算符常用于条件判断和控制流语句中。例如：

```r
# 使用 & 运算符
x <- 6
y <- 10
result <- (x > 5) & (y == 10)  # result 为 TRUE

# 使用 | 运算符
result <- (x < 5) | (y == 10)  # result 为 TRUE

# 使用 ! 运算符
result <- !(x < 5)  # result 为 TRUE
```

### 2.1 且运算符「AND」

`&` 和 `&&`：与运算。如果两个操作数都为真，则条件为真。`&` 是向量化的，会对输入向量的每个元素进行运算，而 `&&` 只会检查第一个元素。

#### 2.1.1 &

逻辑运算符允许您组合多个条件。

逻辑 **& (AND)** 运算符允许你组合两个条件，并且仅当两个条件都为真时才返回真。

例如：

```r
x <- 6
y <- 2
if(x > y & x < 10){
    print("Yes")
}

# ---output---
[1] "Yes"
```

#### 2.1.2 &&

```r
> TRUE & TRUE
[1] TRUE
> TRUE & FALSE
[1] FALSE
> "a" + 9  # 显然是会报错的
Error in "a" + 9 : non-numeric argument to binary operator
> TRUE & "a" + 9  # 第一个为 TRUE 则继续判断右边是否为真，故而报错
Error in "a" + 9 : non-numeric argument to binary operator
> FALSE & "a" + 9  # 第一个为 FALSE 理应不执行右边直接停止，但是从结果可以看出来，右边还是执行了
Error in "a" + 9 : non-numeric argument to binary operator
> TRUE && "a" + 9  # 如果用 && 的时候，第一个为 TRUE，那么第二个肯定报错，这个是正常的
Error in "a" + 9 : non-numeric argument to binary operator
> FALSE && "a" + 9  # 第一个是 FALSE，那么没有报错，表明进行了优化「截断」
[1] FALSE
```

### 2.2 或运算符「OR」

`|` 和 `||`：或运算。如果两个操作数中有任意一个为真，则条件为真。`|` 是向量化的，会对输入向量的每个元素进行运算，而 `||` 只会检查第一个元素。

#### 2.2.1 |

类似地，如果逻辑 **`|(OR)`** 运算符的任何一个条件为 TRUE，则该运算符返回 TRUE：

```r
x <- 6
y <- 2
if(x > y | x > 100) {
    print("Yes")
}

# ---output---
[1] "Yes"
```

#### 2.2.2 ||

```r
> TRUE | TRUE
[1] TRUE
> TRUE | FALSE
[1] TRUE
> FALSE | TRUE
[1] TRUE
> FALSE | FALSE
[1] FALSE
> "A" + 9
Error in "A" + 9 : non-numeric argument to binary operator
> TRUE | "A" + 9
Error in "A" + 9 : non-numeric argument to binary operator
> FALSE | "A" + 9
Error in "A" + 9 : non-numeric argument to binary operator
> FALSE || "A" + 9
Error in "A" + 9 : non-numeric argument to binary operator
> TRUE || "A" + 9
[1] TRUE
```

### 2.3 非运算符「NOT」

`!`：非运算。用于反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将使其为假。

```r
> !TRUE
[1] FALSE
> !FALSE
[1] TRUE
> !!FALSE
[1] FALSE
> !!!FALSE
[1] TRUE
```

### 2.4 异或运算符「XOR」

`xor(x, y)`：异或运算。如果 `x` 和 `y` 中只有一个为真，结果为真。

```r
# 使用 xor 函数
result1 <- xor(TRUE, FALSE)  # result1 为 TRUE
result2 <- xor(TRUE, TRUE)   # result2 为 FALSE
result3 <- xor(FALSE, FALSE) # result3 为 FALSE
```

**【单选题】小测**

在下面这个代码中的结果是什么？

```r
(((15 > 4) & (8 < 9)) | (4 > 6))
```

## 3. switch 语句

`switch` 是一种分支结构，它根据表达式的值选择执行不同的代码块。它类似于其他编程语言中的 `switch` 或 `case` 语句，但有一些差异。

R 中的 `switch` 语句的基本语法是：

```r
switch(EXPR, ...)
```

这里 `EXPR` 是一个返回字符字符串的表达式，后面跟着的是一系列的选项，这些选项可以是值或是执行的表达式。R会将 `EXPR` 的值与后面的选项名匹配，并执行匹配的代码块。

以下是 `switch` 语句的一个简单示例：

```r
x <- 3
result <- switch(x,
                 "1" = "one",
                 "2" = "two",
                 "3" = "three",
                 "No match"
)
print(result)  # 打印 "three"
```

在这个例子中，变量 `x` 的值是 3，所以 `switch` 返回与索引 3 匹配的值 "three"。

### 3.1 字符串匹配

提供要比较的值和匹配时返回的值：

```r
x <- "c"
result <- switch(
    x,
    "a" = "one",
    "b" ="Two",
    "c" = "Three",
    "d" = "Four"
)
print(result)
```

> 不管有几个元素，记住用逗号把它们分开。

### 3.2 匹配规则

- 如果 `EXPR` 是一个数字，那么 `switch` 会选择它的第 `EXPR` 个参数。

- 如果 `EXPR` 是一个字符串，那么 `switch` 会选择与之匹配的标签参数。

如果没有任何匹配项，而你提供了一个没有名称的额外参数，如上例中的 "No match"，`switch` 将返回这个额外参数。如果没有提供这样的参数，`switch` 将不执行任何操作并返回 `NULL`。

::: warning

需要注意的是，R 语言的 `switch` 语句与 C 语言或 Java 中的 `switch` 有所不同，因为 R 语言中的 `switch` 只执行一个匹配的分支，而不需要像其他语言中的 `break` 语句来防止执行下一个分支。此外，R 的 `switch` 只能对单个表达式的结果进行匹配检查，而不是对多个可能的表达式值。

:::

### 3.3 索引匹配

还记得我们编写代码输出给定数字的英文版本吗？它使用多个 **else-if** 语句来检查数字。

R 提供了一个 **switch** 语句来根据值列表测试表达式，与使用 **else-if** 语句相比，它使代码更短。

例如：

```r
num <- 4
result <- switch(
    num,       # 这是索引值
    "one",     # 索引 1
    "Two",     # 索引 2
    "Three ",  # 索引 3
    "Four"     # 索引 4
)
print(result)
```

> **switch** 语句获取其第一个参数并返回其索引对应于该数字的值。

由于 `num` 的值是 4，`switch` 选择第四个参数，因此返回 "Four"。

这种基于索引的选择使得 `switch` 在 R 中的行为与其他编程语言中的 `case` 或 `switch` 语句有所不同，后者基于匹配 `case` 标签来选择执行路径。在 R 中，当 `switch` 的表达式计算为数字时，它简单地选择参数列表中相应位置的元素。如果 `num` 的值超出了参数的数量，`switch` 将返回 `NULL`。

**【单选题】小测**

下面这串代码的输出是什么？

```r
x <- 2
choice <- switch(
    x,
    "Coffee",
    "Tea",
    "Water"
)
```



## 4. 循环

有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。

编程语言提供了更为复杂执行路径的多种控制结构。

循环语句允许我们多次执行一个语句或语句组。

R 语言提供的循环类型有:

- repeat 循环
- while 循环
- for 循环

R 语言提供的循环控制语句有：

- break 语句
- Next 语句

循环控制语句改变你代码的执行顺序，通过它你可以实现代码的跳转。

### 4.1 repeat

repeat 循环会一直执行代码，直到条件语句为 true 时才退出循环，退出要使用到 break 语句。

> 在 R 语言中，`repeat` 是一个用于创建循环的关键词。这个循环会一直执行代码块，直到遇到 `break` 语句。`repeat` 循环不像 `for` 或 `while` 循环那样有明确的循环条件，所以你必须在循环体内部提供一个退出循环的条件，通常是通过 `if` 语句和 `break`。

语法格式如下：

```r
repeat { 
    // 相关代码 
    if(condition) {
       break
    }
}
```

以下实例在变量 cnt 为 5 时退出循环，cnt 为计数变量：

```r
v <- c("AIYC","Bornforthis")
cnt <- 2

repeat {
   print(v)
   cnt <- cnt+1
   
   if(cnt > 5) {
      break
   }
}
```

执行以上代码，输入结果为：

```r
[1] "AIYC"        "Bornforthis"
[1] "AIYC"        "Bornforthis"
[1] "AIYC"        "Bornforthis"
[1] "AIYC"        "Bornforthis"
```

### 4.2 repeat practice

1. **基础计数器**：编写一个程序，使用 `repeat` 循环从1数到10，然后打印每个数字。

```r
# 初始化计数器
counter <- 1

repeat {
    print(counter)
    counter <- counter + 1
    
    # 当计数器达到10时停止
    if (counter > 10) {
        break
    }
}
```

2. **累加求和**：使用 `repeat` 循环计算从1到100的累加和。

```r
# 初始化累加器
sum <- 0
i <- 1

repeat {
    sum <- sum + i
    i <- i + 1
    
    # 当i大于100时停止循环
    if (i > 100) {
        break
    }
}

print(sum)
```

3. **查找数组中的元素**：给定一个数值数组和一个目标值，使用 `repeat` 循环查找目标值是否在数组中，并打印其位置或者一个表示未找到的信息。

```r
# 示例数组和目标值
array <- c(2, 5, 8, 12, 16)
target <- 12

found <- FALSE
i <- 1

repeat {
    if (array[i] == target) {
        print(paste("Found at position:", i))
        found <- TRUE
        break
    }
    i <- i + 1
    
    if (i > length(array)) {
        break
    }
}

if (!found) {
    print("Not found")
}
```

4. **生成斐波那契数列**：使用 `repeat` 循环生成前20个斐波那契数列的数字。

```r
fib <- numeric(20)
fib[1] <- 1
fib[2] <- 1

i <- 3

repeat {
    fib[i] <- fib[i - 1] + fib[i - 2]
    i <- i + 1
    
    if (i > 20) {
        break
    }
}

print(fib)

```

### 4.3 while 循环

只要给定的条件为 TRUE，R 语言中的 while 循环语句会重复执行一个目标语句。

**`while `** 循环具有以下语法：

```r
while (condition) {
    statement(s);
} 
```

在这里，`statement(s)` 可以是一个单独的语句，也可以是几个语句组成的代码块。

condition 可以是任意的表达式，当为任意非零值时都为 TRUE。当条件为 TRUE 时执行循环。 当条件为 FALSE 时，退出循环，程序流将继续执行紧接着循环的下一条语句。

以下实例在在变量 cnt 小于 7 时输出 while 语句块中的内容，cnt 为计数变量：

```python
v <- c("Bornforthis.cn","Google")
cnt <- 2

while (cnt < 7) {
   print(v)
   cnt = cnt + 1
}

# 输出：
[1] "Bornforthis.cn" "Google"        
[1] "Bornforthis.cn" "Google"        
[1] "Bornforthis.cn" "Google"        
[1] "Bornforthis.cn" "Google"        
[1] "Bornforthis.cn" "Google" 
```

让我们用它来输出数字 1 到 9：

```r
i <- 1
while (i < 10){
    print(i)
    i <- i + 1
}
```

效果演示:

```r
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
```

上面的代码检查 i 是否小于 10，输出其值，然后将其递增 1。

这意味着循环将输出数字 1 到 9，并在达到值 10 时停止。

每次计算机运行一个循环时，它被称为一次迭代。

> 在 while 循环的迭代过程中更改条件的值非常重要，因为不这样做将导致无限循环，因为条件始终保持为真（TRUE）。

### 4.4 while 注意事项

- **无限循环**: 如果循环条件永远为真，`while` 循环将无限进行。要避免这种情况，请确保循环的某个部分能够改变条件，使其最终变为 `FALSE`。
- **循环控制**: 可以使用 `break` 语句提前退出循环，或使用 `next` 语句跳过当前迭代的剩余部分。
- **性能考虑**: 对于大数据集或复杂的条件，`while` 循环可能导致性能问题。在这种情况下，可能需要考虑其他循环结构或向量化操作。

`while` 循环在数据分析和统计建模等任务中非常有用，它允许你在满足特定条件之前，对数据集执行重复操作。

### 4.5 while practice

1. 使用 while 循环检查从 20 到 1 的每个数字是否是偶数或奇数，并相应地打印消息。

示例输出：

```r
[1] "20 is even"
[1] "19 is odd"
[1] "18 is even"
[1] "17 is odd"
[1] "16 is even"
[1] "15 is odd"
[1] "14 is even"
[1] "13 is odd"
[1] "12 is even"
[1] "11 is odd"
[1] "10 is even"
[1] "9 is odd"
[1] "8 is even"
[1] "7 is odd"
[1] "6 is even"
[1] "5 is odd"
[1] "4 is even"
[1] "3 is odd"
[1] "2 is even"
[1] "1 is odd"
```

::: details Answer

```r
num <- 20
while (num > 0) {
  if (num %% 2 == 0) {
    print(paste(num, "is even"))
  } else {
    print(paste(num, "is odd"))
  }
  num <- num - 1
}
```

:::

2. **数字游戏：** 

    编写一个程序，生成一个 1 到 100 之间的随机数。然后使用 `while` 循环，让用户猜这个数字，如果猜对了，告诉用户猜对了并结束循环；如果猜错，根据数字是太大还是太小给出提示。

::: details Answer

```r
set.seed(123)  # 设置随机数种子
target <- sample(1:100, 1)
while (TRUE) {
  guess <- as.integer(readline(prompt = "Guess a number (1-100): "))
  if (guess == target) {
    print("Correct! You guessed the number.")
    break
  } else if (guess < target) {
    print("Too low. Try again.")
  } else {
    print("Too high. Try again.")
  }
}
```

:::

### 4.6  For 循环

R 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。

它用于对给定序列进行迭代。

语法格式如下：

```r
for (value in vector) {
    statements
}
```

R 语言的 for 循环特别灵活，不仅可以循环整数变量，还可以对字符向量，逻辑向量，列表等数据类型进行迭代。

以下实例输出 26 个字母对前面四个字母：

```r
v <- LETTERS[1:4]
for ( i in v) {
   print(i)
}
```

执行以上代码，输入结果为：

```r
[1] "A"
[1] "B"
[1] "C"
[1] "D"
```

例如输出 1:10 之间的数字：

```r
for (x in 1:10){
    print(x)
}
```

效果如下所示：

```r
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```

R 允许我们通过使用冒号并指定上下限来创建数字序列。上述代码中的顺序将包括数字 1 到 10。

在 `for `循环的每次迭代中，x 变量将取序列中下一个数字的值，因此，结果输出将是数字 1 到 10。

>  for 循环还用于迭代列表和向量。我们将在接下来的模块中了解它们。

**【填空题】小测**

将下面代码填充完整使得可以仅输出 1 到 100 顺序中的偶数。

如果除以 2，余数为 0，则数字为偶数。

```r
___(x in 1 ___ 100) {
___ (x%%2 == 0) {
    print(___)
}
}
```

### 4.7 for practice





### 4.7 break 与 next

#### 4.7.1 break 语句

> **break** 语句允许你停止循环。

R 语言的 break 语句插入在循环体中，用于退出当前循环或语句，并开始脚本执行紧接着的语句。

如果你使用循环嵌套，break 语句将停止最内层循环的执行，并开始执行的外层的循环语句。

break 也常用于 switch 语句中。

语法格式如下：

```r
break
```

以下实例在变量 cnt 为 5 时使用 break 退出循环，cnt 为计数变量：

```r
v <- c("Google","Bornforthis")
cnt <- 2

repeat {
   print(v)
   cnt <- cnt+1
   
   if(cnt > 5) {
      break
   }
}
```

执行以上代码，输入结果为：

```r
[1] "Google"      "Bornforthis"
[1] "Google"      "Bornforthis"
[1] "Google"      "Bornforthis"
[1] "Google"      "Bornforthis"
```









::: details

R语言中的逻辑运算符主要包括以下几种：

1. `&` 和 `&&`：与运算。如果两个操作数都为真，则条件为真。`&` 是向量化的，会对输入向量的每个元素进行运算，而 `&&` 只会检查第一个元素。

2. `|` 和 `||`：或运算。如果两个操作数中有任意一个为真，则条件为真。`|` 是向量化的，会对输入向量的每个元素进行运算，而 `||` 只会检查第一个元素。

3. `!`：非运算。用于反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将使其为假。

4. `xor(x, y)`：异或运算。如果 `x` 和 `y` 中只有一个为真，结果为真。

这些运算符通常用于条件语句和循环中的逻辑判断。例如：

```R
# 创建两个逻辑向量
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(TRUE, TRUE, FALSE, FALSE)

# 与运算
print(x & y)  # 输出：TRUE FALSE FALSE FALSE

# 或运算
print(x | y)  # 输出：TRUE TRUE TRUE FALSE

# 非运算
print(!x)     # 输出：FALSE TRUE FALSE TRUE

# 异或运算
print(xor(x, y))  # 输出：FALSE TRUE TRUE FALSE
```

请注意，逻辑运算符返回的结果也是逻辑值，可以是 `TRUE`（真）、`FALSE`（假）或 `NA`（缺失值）。



当然，以下是使用R语言逻辑运算符的一些示例：

1. `&` 和 `&&` 的使用示例：

```R
# 创建两个逻辑向量
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(TRUE, TRUE, FALSE, FALSE)

# 使用 '&' 运算符
result <- x & y
print(result)  # 输出：TRUE FALSE FALSE FALSE

# 使用 '&&' 运算符
result <- x[1] && y[1]
print(result)  # 输出：TRUE
```

2. `|` 和 `||` 的使用示例：

```R
# 创建两个逻辑向量
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(TRUE, TRUE, FALSE, FALSE)

# 使用 '|' 运算符
result <- x | y
print(result)  # 输出：TRUE TRUE TRUE FALSE

# 使用 '||' 运算符
result <- x[1] || y[1]
print(result)  # 输出：TRUE
```

3. `!` 的使用示例：

```R
# 创建一个逻辑向量
x <- c(TRUE, FALSE, TRUE, FALSE)

# 使用 '!' 运算符
result <- !x
print(result)  # 输出：FALSE TRUE FALSE TRUE
```

4. `xor(x, y)` 的使用示例：

```R
# 创建两个逻辑向量
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(TRUE, TRUE, FALSE, FALSE)

# 使用 'xor' 函数
result <- xor(x, y)
print(result)  # 输出：FALSE TRUE TRUE FALSE
```

以上代码均可以在R环境中运行。





在R语言中，`c()`函数是一个基本函数，用于创建向量或者将多个向量组合成一个。`c`实际上是`combine`的缩写，表示组合。

例如，你可以使用`c()`创建一个数值向量：

```R
numbers <- c(1, 2, 3, 4, 5)
print(numbers)
# 输出：1 2 3 4 5
```

或者创建一个字符向量：

```R
characters <- c("a", "b", "c", "d", "e")
print(characters)
# 输出："a" "b" "c" "d" "e"
```

你也可以用它来合并向量：

```R
numbers1 <- c(1, 2, 3)
numbers2 <- c(4, 5, 6)
combined <- c(numbers1, numbers2)
print(combined)
# 输出：1 2 3 4 5 6
```

所以，在我之前的示例中，`c(TRUE, FALSE, TRUE, FALSE)`是创建了一个逻辑向量。

:::

- [ ] R 语言变量命名规则
- [ ] Switch 后面可以接什么类型？
- [ ] R 语言各种类型转换汇总

欢迎关注我公众号：AI悦创，有更多更好玩的等你发现！

::: details 公众号：AI悦创【二维码】

![](/gzh.jpg)

:::

::: info AI悦创·编程一对一

AI悦创·推出辅导班啦，包括「Python 语言辅导班、C++ 辅导班、java 辅导班、算法/数据结构辅导班、少儿编程、pygame 游戏开发」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践等。当然，还有线下线上摄影课程、Photoshop、Premiere 一对一教学、QQ、微信在线，随时响应！微信：Jiabcdefh

C++ 信息奥赛题解，长期更新！长期招收一对一中小学信息奥赛集训，莆田、厦门地区有机会线下上门，其他地区线上。微信：Jiabcdefh

方法一：[QQ](http://wpa.qq.com/msgrd?v=3&uin=1432803776&site=qq&menu=yes)

方法二：微信：Jiabcdefh

:::

![](/zsxq.jpg)
