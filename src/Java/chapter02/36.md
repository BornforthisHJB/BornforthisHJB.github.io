---
title: 36-参数：让 Merchandise 计算多件商品的总价
date: 2024-12-31 09:48:38
icon: java
author: AI悦创
isOriginal: true
category: 
    - Java体系课
tag:
    - Java体系课
sticky: false
star: false
article: true
timeline: true
image: false
navbar: true
sidebarIcon: true
headerDepth: 5
comment: true
lastUpdated: true
editLink: false
backToTop: true
toc: true
footer: 长期招收编程一对一学员！微信：Jiabcdefh, <a href="https://beian.miit.gov.cn/" target="_blank">闽ICP备19021486号-6</a>
---

## 0. 目录

- 第二件半价哦！
- 参数：告诉商品实例要购买多少个

## 1. 第二件半价哦！

::: code-tabs

@tab RunLittleSupperMarketAppMain

```java {37-63}
package com.bornforthis;

import com.bornforthis.supermarket.LittleSuperMarket;
import com.bornforthis.supermarket.MerchandiseV2;

import java.util.Scanner;

public class RunLittleSupperMarketAppMain {
    public static void main(String[] args) {
        // 创建一个小超市类
        LittleSuperMarket littleSuperMarket = new LittleSuperMarket();
        // 依次给超市的名字，地址，停车位赋值
        littleSuperMarket.superMarketName = "有家小超市";
        littleSuperMarket.address = "浦东新区世纪大道666号";
        littleSuperMarket.parkingCount = 100;
        // 给超市200种商品
        littleSuperMarket.merchandises = new MerchandiseV2[200];
        // 统计用的数组
        littleSuperMarket.merchandiseSold = new int[littleSuperMarket.merchandises.length];

        // 为了使用方便，创建一个商品数组引用，和littleSuperMarket.merchandises指向同一个数组对象
        MerchandiseV2[] all = littleSuperMarket.merchandises;

        // 遍历并给200种商品赋值
        for (int i = 0; i < all.length; i++) {
            // 创建并给商品的属性赋值
            MerchandiseV2 m = new MerchandiseV2();
            m.name = "商品" + i;
            m.count = 200;
            m.purchasePrice = Math.random() * 200;
            m.soldPrice = m.purchasePrice * (1 + Math.random());
            m.id = "ID" + i;
            // 用创建的商品，给商品数组的第i个引用赋值，all和小超市的商品数组引用指向的是同一个数组对象
            all[i] = m;
        }

        // 创建一个Scanner读取输入
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.println("今日超市大特惠，所有商品第二件半价！选择要购买的商品索引：");
            int index = scanner.nextInt();
            if (index < 0) {
                System.out.println("欢迎再次光临！");
                break;
            }
            double price = littleSuperMarket.merchandises[index].purchasePrice;
            System.out.println("商品单价为" + price);

            System.out.println("请输入要购买的数量：");
            int count = scanner.nextInt();

            if (littleSuperMarket.merchandises[index].count < count) {
                System.out.println("商品库存不足。");
                continue;
            }

            int fullPriceCount = count / 2 + count % 2;
            int halfPriceCount = count - fullPriceCount;
            double totalCost = price * fullPriceCount + halfPriceCount * price / 2;

            littleSuperMarket.merchandises[index].count -= count;

            System.out.println("商品总价为：" + totalCost);
        }

    }
}
```

@tab RunLittleSupperMarketAppMainExample

```java
package com.geekbang;

import com.geekbang.supermarket.LittleSuperMarket;
import com.geekbang.supermarket.MerchandiseV2;

import java.util.Scanner;

public class RunLittleSupperMarketAppMainExample {
    public static void main(String[] args) {
        // 创建一个小超市类
        LittleSuperMarket littleSuperMarket = new LittleSuperMarket();
        // 依次给超市的名字，地址，停车位赋值
        littleSuperMarket.superMarketName = "有家小超市";
        littleSuperMarket.address = "浦东新区世纪大道666号";
        littleSuperMarket.parkingCount = 100;
        // 给超市200种商品
        littleSuperMarket.merchandises = new MerchandiseV2[200];
        // 统计用的数组
        littleSuperMarket.merchandiseSold = new int[littleSuperMarket.merchandises.length];

        // 为了使用方便，创建一个商品数组引用，和littleSuperMarket.merchandises指向同一个数组对象
        MerchandiseV2[] all = littleSuperMarket.merchandises;

        // 遍历并给200种商品赋值
        for (int i = 0; i < all.length; i++) {
            // 创建并给商品的属性赋值
            MerchandiseV2 m = new MerchandiseV2();
            m.name = "商品" + i;
            m.count = 200;
            m.purchasePrice = Math.random() * 200;
            m.soldPrice = m.purchasePrice * (1 + Math.random());
            m.id = "ID" + i;
            // 用创建的商品，给商品数组的第i个引用赋值，all和小超市的商品数组引用指向的是同一个数组对象
            all[i] = m;
        }

        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("今日超市大特惠，所有商品第二件半价！选择要购买的商品索引：");
            int index = scanner.nextInt();

            if (index < 0) {
                break;
            }

            if (index >= all.length) {
                System.out.println("商品索引超出界限");
                continue;
            }

            MerchandiseV2 m = all[index];
            System.out.println("商品" + m.name + "售价为" + m.soldPrice + "。请问购买几个？");
            int numToBuy = scanner.nextInt();

            if (numToBuy > m.count) {
                System.out.println("库存不足");
                continue;
            }

            int fullPriceCount = numToBuy / 2 + numToBuy % 2;
            int halfPriceCount = numToBuy - fullPriceCount;

            double totalCost = fullPriceCount * m.soldPrice + (halfPriceCount * m.soldPrice / 2);

            m.count -= numToBuy;

            System.out.println("选购的商品总价为" + totalCost);
        }


    }
}
```





:::

### 1.1 半件实现逻辑详解

`count / 2 + count % 2;`公式解析，可以除的尽的，是偶数的倍数，那就是购买两件的数量。而余数则是：没有买两件「偶数」的件数。

**让我们一步步分析：**

1. `fullPriceCount = count / 2 + count % 2`

    - 这行代码计算需要支付全价的商品数量

    - `count / 2` 是整数除法，得到商品总数的一半（向下取整）

    - `count % 2` 是取余操作，当总数为奇数时等于1，偶数时等于0

    - 实际效果是：对于奇数个商品，全价商品会比半价商品多一个

    - **举例：**

        - 如果 `count = 5`

        - `count} / 2 = 2`（整数除法）

        - `count % 2 = 1`

        - `fullPriceCount} = 2 + 1 = 3`（需要支付全价的商品数）

2. `halfPriceCount = count - fullPriceCount`

    - 这行简单地用总数减去全价商品数，得到半价商品数

    - 继续上面的例子，`halfPriceCount = 5 - 3 = 2`

3. `totalCost = price * fullPriceCount + halfPriceCount * price / 2`
    1. `计算总价：全价商品数量 × 单价 + 半价商品数量 × (单价/2)`

实现一个"买二赠一半价"的促销策略，其中：

- 当总数为偶数时，正好各一半商品全价和半价
- 当总数为奇数时，全价商品会比半价商品多一个

让我用具体数字举例说明：

```java
// 假设 price = 100
// 情况1：买5个
count = 5
fullPriceCount = 5/2 + 5%2 = 2 + 1 = 3  // 3个全价
halfPriceCount = 5 - 3 = 2  // 2个半价
totalCost = 100*3 + 2*100/2 = 300 + 100 = 400

// 情况2：买6个
count = 6
fullPriceCount = 6/2 + 6%2 = 3 + 0 = 3  // 3个全价
halfPriceCount = 6 - 3 = 3  // 3个半价
totalCost = 100*3 + 3*100/2 = 300 + 150 = 450
```

这种计算方式确保了：

1. 商品总是尽可能平均分配为全价和半价
2. 当数量为奇数时，多出的一个商品按全价计算
3. 保证了商家在促销的同时维持基本利润

### 1.2 这种方式有哪些问题？

- 每个用到这个逻辑的地方，都要重复这段代码
- 如果告诉商品要买多少个，商品帮我算多少钱，就不用重复代码了





## 2. LittleSuperMarket 实现

::: code-tabs

@tab LittleSuperMarket

```java {15-18}
package com.bornforthis.supermarket;

public class LittleSuperMarket {
    public String superMarketName;
    public String address;
    public int parkingCount;
    public double incomingSum;
    public MerchandiseV2[] merchandises;
    public int[] merchandiseSold;

    public MerchandiseV2 getBiggestProfitMerchandise() {
        MerchandiseV2 curr = null;
        for (int i = 0; i < merchandises.length; i++) {
            MerchandiseV2 m = merchandises[i];
            // 这个逻辑有问题吗？相同的利润怎么判断？
            if (curr == null || curr.calculateProfit() < m.calculateProfit()) {
                curr = m;
            }
        }
        return curr;
    }
}
```

:::

### 2.1 保留相同最大值的前后问题

先分析问题：在当前的代码实现中，`if (curr == null || curr.calculateProfit() < m.calculateProfit())` 这个条件只处理了两种情况：

1. curr 为空（第一个商品的情况）

2. 当前商品的利润大于已保存商品的利润

这个逻辑确实存在一个问题：当两个商品的利润相同时，它会保留第一个遇到的最高利润商品。这可能不是最合理的处理方式，因为在利润相同的情况下，我们可能还需要考虑其他因素。

这里有几种可能的改进方案：

1. 方案一：如果就是要保留第一个最高利润商品，那么当前逻辑是可以的，但最好明确注释说明这是有意为之：

    ```java
    // 当利润相同时，保留第一个最高利润的商品
    if (curr == null || curr.calculateProfit() < m.calculateProfit()) {
        curr = m;
    }
    ```

    【证明】保留的最大相同毛利润是保留第一个还是最后一个？

    ```java
    package com.bornforthis;
    
    public class Main {
        public static void main(String[] args) {
            int[] arr = {1, 2, 3, 4, 5, 10, 9, 10, 8, 10};
            int max = arr[0];
            int maxIndex = 0;
            for (int i = 0; i < arr.length; i++) {
                if (arr[i] > max) {
                    max = arr[i];
                    maxIndex = i;
                }
            }
            System.out.println(maxIndex);
        }
    }
    
    // 输出
    5
    
    // TODO：可知返回的是第一个最大值
    ```

    不保留最后的相同的最大值下标是什么情况？因为不论是 `>` 还是 `<` 都不会执行相同的情况（3 > 3 => false），只有在 （3 >= 3 => true）

    保留最后一个最大值，只需要修改如下代码：

    ```java
    if (arr[i] >= max)
    ```

2. 方案二：如果要保留最后一个最高利润商品，可以改为：

    ```java
    if (curr == null || curr.calculateProfit() <= m.calculateProfit()) {
        curr = m;
    }
    ```

3. 方案三：如果遇到相同利润要按照其他条件判断（比如销量、库存等），可以这样处理：

    ```java {24-39}
    /*
     * @Time    : 2024/12/31 10:12
     * @Author  : AI悦创
     * @FileName: LittleSuperMarket.java
     * @Software: IntelliJ IDEA
     * @Version: V1.0
     * @Blog    : https://bornforthis.cn/
     * Code is far away from bugs with the god animal protecting
     * I love animals. They taste delicious.
     */
    package com.bornforthis.supermarket;
    
    public class LittleSuperMarket {
        public String superMarketName;
        public String address;
        public int parkingCount;
        public double incomingSum;
        public MerchandiseV2[] merchandises;
        public int[] merchandiseSold;
    
        public MerchandiseV2 getBiggestProfitMerchandise() {
            MerchandiseV2 curr = null;
            for (int i = 0; i < merchandises.length; i++) {
                MerchandiseV2 m = merchandises[i];
                if (curr == null) {
                    curr = m;
                } else {
                    double currProfit = curr.calculateProfit();
                    double mProfit = m.calculateProfit();
                    if (currProfit < mProfit) {
                        curr = m;
                    } else if (currProfit == mProfit) {
                        System.out.println("发现相同的利润商品，商品索引为：" + i);
                        // TODO: 相同库存情况下，库存数量少的，表明销量高！
                        if (curr.count > m.count) {
                            curr = m;
                        }
                    }
                }
    
            }
            return curr;
        }
    
    }
    ```

4. 建议选择哪种方案，取决于具体的业务需求：

    - 如果只关心找出最高利润，不在意是第一个还是最后一个，用方案1或2都可以
    - 如果在利润相同时还需要考虑其他因素，建议使用方案3
    - 无论选择哪种方案，都建议添加注释说明处理相同利润的策略，以便其他开发者理解代码逻辑



## 3. 参数：告诉商品实例要购买多少个

看 MerchandiseV2 中的新方法，学习方法参数相关语法

::: code-tabs

@tab MerchandiseV2

```java
```



:::





## 4. RunLittleSupperMarketAppMainV2





















欢迎关注我公众号：AI悦创，有更多更好玩的等你发现！

::: details 公众号：AI悦创【二维码】

![](/gzh.jpg)

:::

::: info AI悦创·编程一对一

AI悦创·推出辅导班啦，包括「Python 语言辅导班、C++ 辅导班、java 辅导班、算法/数据结构辅导班、少儿编程、pygame 游戏开发」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践等。当然，还有线下线上摄影课程、Photoshop、Premiere 一对一教学、QQ、微信在线，随时响应！微信：Jiabcdefh

C++ 信息奥赛题解，长期更新！长期招收一对一中小学信息奥赛集训，莆田、厦门地区有机会线下上门，其他地区线上。微信：Jiabcdefh

方法一：[QQ](http://wpa.qq.com/msgrd?v=3&uin=1432803776&site=qq&menu=yes)

方法二：微信：Jiabcdefh

:::

![](/zsxq.jpg)
