import{_ as n}from"./gzh-DnOBNg6W.js";import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as p}from"./app-B5JagD1b.js";const i={};function o(r,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h2 id="_1-初识二叉树" tabindex="-1"><a class="header-anchor" href="#_1-初识二叉树"><span>1. 初识二叉树</span></a></h2><p>你好，我是悦创。</p><p><strong>二叉树</strong>是一个有限元素的集合，这个集合要么是空集，要么是由一个称为根的元素以及两个不相交的、分别称为左子树和右子树的二叉树组成。</p><p>让我们使用文本来表示一个二叉树。</p><p>考虑这样一个简单的二叉树：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span>    1</span></span>
<span class="line"><span>   / \\</span></span>
<span class="line"><span>  2   3</span></span>
<span class="line"><span> / \\ / \\</span></span>
<span class="line"><span>4  5 6  7</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这棵树的根是 1。</li><li>1 的左子树是以 2 为根的二叉树，右子树是以 3 为根的二叉树。</li><li>2 的左子节点是 4，右子节点是 5；3 的左子节点是 6，右子节点是 7。</li></ul><p><strong>前序遍历</strong> (根-左-右)：1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p><p><strong>中序遍历</strong> (左-根-右)：4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</p><p><strong>后序遍历</strong> (左-右-根)：4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1</p><p>这种以文本方式表示的二叉树可以帮助你在没有图形界面的情况下更好地理解二叉树的结构和遍历方式。不过，当树结构更复杂时，这种方式可能不如图形直观。</p><h2 id="_2-探究前中后序遍历" tabindex="-1"><a class="header-anchor" href="#_2-探究前中后序遍历"><span>2. 探究前中后序遍历</span></a></h2><p>前序、中序和后序遍历是二叉树的三种基本的遍历方式，它们描述了访问树的节点的顺序。具体来说：</p><ol><li><p><strong>前序遍历 (Pre-order Traversal)</strong></p><ul><li>先访问根节点。</li><li>再递归地遍历左子树。</li><li>最后递归地遍历右子树。</li></ul><p>对于之前的示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span>    1</span></span>
<span class="line"><span>   / \\</span></span>
<span class="line"><span>  2   3</span></span>
<span class="line"><span> / \\ / \\</span></span>
<span class="line"><span>4  5 6  7</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前序遍历的结果是：1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p></li><li><p><strong>中序遍历 (In-order Traversal)</strong></p><ul><li>先递归地遍历左子树。</li><li>然后访问根节点。</li><li>最后递归地遍历右子树。</li></ul><p>对于上述示例，中序遍历的结果是：4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</p><p>注意：当二叉树是一个二叉搜索树时，中序遍历将输出升序的值。</p></li><li><p><strong>后序遍历 (Post-order Traversal)</strong></p><ul><li>先递归地遍历左子树。</li><li>再递归地遍历右子树。</li><li>最后访问根节点。</li></ul><p>对于上述示例，后序遍历的结果是：4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1</p></li></ol><p>理解这三种遍历方式的关键是观察根节点的访问顺序相对于其左右子树的顺序。在实际应用中，这三种遍历方式根据需要有各自的应用场景，例如在某些算法和问题求解中。</p><h2 id="_3-二叉树的基本实现" tabindex="-1"><a class="header-anchor" href="#_3-二叉树的基本实现"><span>3. 二叉树的基本实现</span></a></h2><h3 id="_3-1-构建-node-类" tabindex="-1"><a class="header-anchor" href="#_3-1-构建-node-类"><span>3.1 构建 Node 类</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;"># 定义二叉树的节点</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">Node</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#66D9EF;"> __init__</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">key</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 左子节点</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.left </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> None</span></span>
<span class="line"><span style="color:#88846F;">        # 右子节点</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.right </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> None</span></span>
<span class="line"><span style="color:#88846F;">        # 当前节点的值</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.val </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> key</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-创建-binarytree-类" tabindex="-1"><a class="header-anchor" href="#_3-2-创建-binarytree-类"><span>3.2 创建 BinaryTree 类</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">BinaryTree</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#66D9EF;"> __init__</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 初始化时树是空的，根节点为 None</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.root </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> None</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-编写插入函数-insert" tabindex="-1"><a class="header-anchor" href="#_3-3-编写插入函数-insert"><span>3.3 编写插入函数 insert</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">    # 插入一个新的值到二叉搜索树中</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> insert</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">key</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果树是空的，则直接创建一个新的根节点</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F92672;"> not</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">.root:</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">.root </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> Node(key)</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">            # 如果树不是空的，递归地插入新值</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">._insert_recursive(</span><span style="color:#FD971F;">self</span><span style="color:#F8F8F2;">.root, key)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-编写递归插入子树-insert-recursive" tabindex="-1"><a class="header-anchor" href="#_3-4-编写递归插入子树-insert-recursive"><span>3.4 编写递归插入子树 _insert_recursive</span></a></h3><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" data-title="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">    # 递归地将新值插入到二叉搜索树的适当位置</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> _insert_recursive</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">node</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">key</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果新值小于当前节点的值，插入到左子树</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> key </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> node.val:</span></span>
<span class="line"><span style="color:#88846F;">            # 如果左子节点是空的，直接在该位置创建新节点</span></span>
<span class="line"><span style="color:#F92672;">            if</span><span style="color:#F8F8F2;"> node.left </span><span style="color:#F92672;">is</span><span style="color:#F8F8F2;"> Node:</span></span>
<span class="line"><span style="color:#F8F8F2;">                node.left </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> Node(key)</span></span>
<span class="line"><span style="color:#F92672;">            else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">                # 如果左子节点不是空的，递归地插入到左子树</span></span>
<span class="line"><span style="color:#FD971F;">                self</span><span style="color:#F8F8F2;">._insert_recursive(node.left, key)</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">            # 如果新值大于或等于当前节点的值，插入到右子树</span></span>
<span class="line"><span style="color:#F92672;">            if</span><span style="color:#F8F8F2;"> node.right </span><span style="color:#F92672;">is</span><span style="color:#AE81FF;"> None</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#F8F8F2;">                node.right </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> Node(key)</span></span>
<span class="line"><span style="color:#F92672;">            else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">                # 如果右子节点不是空的，递归地插入到右子树</span></span>
<span class="line"><span style="color:#FD971F;">                self</span><span style="color:#F8F8F2;">._insert_recursive(node.right, key)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><h3 id="_3-5-编写可遍历的-inorder" tabindex="-1"><a class="header-anchor" href="#_3-5-编写可遍历的-inorder"><span>3.5 编写可遍历的 inorder</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">    # 返回二叉搜索树的中序遍历结果</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> inorder</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">._inorder_recursive(</span><span style="color:#FD971F;">self</span><span style="color:#F8F8F2;">.root, [])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-6-实现中序遍历-inorder-recursive" tabindex="-1"><a class="header-anchor" href="#_3-6-实现中序遍历-inorder-recursive"><span>3.6 实现中序遍历 _inorder_recursive</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">    # 递归地进行中序遍历</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> _inorder_recursive</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">node</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">result</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果当前节点不是空的</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> node:</span></span>
<span class="line"><span style="color:#88846F;">            # 首先遍历左子树</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">._inorder_recursive(node.left, result)</span></span>
<span class="line"><span style="color:#88846F;">            # 然后访问当前节点</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(node.val)</span></span>
<span class="line"><span style="color:#88846F;">            # 最后遍历右子树</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">._inorder_recursive(node.right, result)</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#F8F8F2;"> result</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-7-主程序" tabindex="-1"><a class="header-anchor" href="#_3-7-主程序"><span>3.7 主程序</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;"># 主程序</span></span>
<span class="line"><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> __name__ </span><span style="color:#F92672;">==</span><span style="color:#E6DB74;"> &quot;__main__&quot;</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">    # 创建一个空的二叉搜索树</span></span>
<span class="line"><span style="color:#F8F8F2;">    bt </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> BinaryTree()</span></span>
<span class="line"><span style="color:#88846F;">    # 向树中插入一些值</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> val </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> [</span><span style="color:#AE81FF;">20</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">10</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">30</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">15</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">25</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">35</span><span style="color:#F8F8F2;">]:</span></span>
<span class="line"><span style="color:#F8F8F2;">        bt.insert(val)</span></span>
<span class="line"><span style="color:#88846F;">    # 打印树的中序遍历结果</span></span>
<span class="line"><span style="color:#66D9EF;">    print</span><span style="color:#F8F8F2;">(bt.inorder())  </span><span style="color:#88846F;"># 预期输出: [5, 10, 15, 20, 25, 30, 35]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-8-完整代码" tabindex="-1"><a class="header-anchor" href="#_3-8-完整代码"><span>3.8 完整代码</span></a></h3><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" data-title="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;"># 定义二叉树的节点</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">Node</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#66D9EF;"> __init__</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">key</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 左子节点</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.left </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> None</span></span>
<span class="line"><span style="color:#88846F;">        # 右子节点</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.right </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> None</span></span>
<span class="line"><span style="color:#88846F;">        # 当前节点的值</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.val </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> key</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 定义二叉搜索树</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">BinaryTree</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#66D9EF;"> __init__</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 初始化时树是空的，根节点为None</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.root </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> None</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 插入一个新的值到二叉搜索树中</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> insert</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">key</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果树是空的，则直接创建一个新的根节点</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F92672;"> not</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">.root:</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">.root </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> Node(key)</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">            # 如果树不是空的，递归地插入新值</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">._insert_recursive(</span><span style="color:#FD971F;">self</span><span style="color:#F8F8F2;">.root, key)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 递归地将新值插入到二叉搜索树的适当位置</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> _insert_recursive</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">node</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">key</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果新值小于当前节点的值，插入到左子树</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> key </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> node.val:</span></span>
<span class="line"><span style="color:#88846F;">            # 如果左子节点是空的，直接在该位置创建新节点</span></span>
<span class="line"><span style="color:#F92672;">            if</span><span style="color:#F8F8F2;"> node.left </span><span style="color:#F92672;">is</span><span style="color:#AE81FF;"> None</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#F8F8F2;">                node.left </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> Node(key)</span></span>
<span class="line"><span style="color:#F92672;">            else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">                # 如果左子节点不是空的，递归地插入到左子树</span></span>
<span class="line"><span style="color:#FD971F;">                self</span><span style="color:#F8F8F2;">._insert_recursive(node.left, key)</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">            # 如果新值大于或等于当前节点的值，插入到右子树</span></span>
<span class="line"><span style="color:#F92672;">            if</span><span style="color:#F8F8F2;"> node.right </span><span style="color:#F92672;">is</span><span style="color:#AE81FF;"> None</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#F8F8F2;">                node.right </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> Node(key)</span></span>
<span class="line"><span style="color:#F92672;">            else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">                # 如果右子节点不是空的，递归地插入到右子树</span></span>
<span class="line"><span style="color:#FD971F;">                self</span><span style="color:#F8F8F2;">._insert_recursive(node.right, key)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 返回二叉搜索树的中序遍历结果</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> inorder</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">._inorder_recursive(</span><span style="color:#FD971F;">self</span><span style="color:#F8F8F2;">.root, [])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 递归地进行中序遍历</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> _inorder_recursive</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">node</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">result</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果当前节点不是空的</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> node:</span></span>
<span class="line"><span style="color:#88846F;">            # 首先遍历左子树</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">._inorder_recursive(node.left, result)</span></span>
<span class="line"><span style="color:#88846F;">            # 然后访问当前节点</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(node.val)</span></span>
<span class="line"><span style="color:#88846F;">            # 最后遍历右子树</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">._inorder_recursive(node.right, result)</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#F8F8F2;"> result</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 主程序</span></span>
<span class="line"><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> __name__ </span><span style="color:#F92672;">==</span><span style="color:#E6DB74;"> &quot;__main__&quot;</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">    # 创建一个空的二叉搜索树</span></span>
<span class="line"><span style="color:#F8F8F2;">    bt </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> BinaryTree()</span></span>
<span class="line"><span style="color:#88846F;">    # 向树中插入一些值</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> val </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> [</span><span style="color:#AE81FF;">20</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">10</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">30</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">15</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">25</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">35</span><span style="color:#F8F8F2;">]:</span></span>
<span class="line"><span style="color:#F8F8F2;">        bt.insert(val)</span></span>
<span class="line"><span style="color:#88846F;">    # 打印树的中序遍历结果</span></span>
<span class="line"><span style="color:#66D9EF;">    print</span><span style="color:#F8F8F2;">(bt.inorder())  </span><span style="color:#88846F;"># 预期输出: [5, 10, 15, 20, 25, 30, 35]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><p>欢迎关注我公众号：AI悦创，有更多更好玩的等你发现！</p><details class="hint-container details"><summary>公众号：AI悦创【二维码】</summary><figure><img src="`+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></details><div class="hint-container info"><p class="hint-container-title">AI悦创·编程一对一</p><p>AI悦创·推出辅导班啦，包括「Python 语言辅导班、C++ 辅导班、java 辅导班、算法/数据结构辅导班、少儿编程、pygame 游戏开发」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践等。当然，还有线下线上摄影课程、Photoshop、Premiere 一对一教学、QQ、微信在线，随时响应！微信：Jiabcdefh</p><p>C++ 信息奥赛题解，长期更新！长期招收一对一中小学信息奥赛集训，莆田、厦门地区有机会线下上门，其他地区线上。微信：Jiabcdefh</p><p>方法一：<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=1432803776&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener noreferrer">QQ</a></p><p>方法二：微信：Jiabcdefh</p></div>',35)]))}const d=l(i,[["render",o],["__file","01-binary-tree.html.vue"]]),y=JSON.parse('{"path":"/Python/Python-core-technology-and-practice/Casual-essay/01-binary-tree.html","title":"二叉树基础","lang":"zh-CN","frontmatter":{"title":"二叉树基础","icon":"tree1","date":"2023-08-27T23:05:47.000Z","author":"AI悦创","isOriginal":true,"category":"Python 进阶","tag":["Python 进阶"],"sticky":false,"star":false,"article":true,"timeline":true,"image":false,"navbar":true,"sidebarIcon":true,"headerDepth":5,"comment":true,"lastUpdated":true,"editLink":false,"backToTop":true,"toc":true,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"1. 初识二叉树","slug":"_1-初识二叉树","link":"#_1-初识二叉树","children":[]},{"level":2,"title":"2. 探究前中后序遍历","slug":"_2-探究前中后序遍历","link":"#_2-探究前中后序遍历","children":[]},{"level":2,"title":"3. 二叉树的基本实现","slug":"_3-二叉树的基本实现","link":"#_3-二叉树的基本实现","children":[{"level":3,"title":"3.1 构建 Node 类","slug":"_3-1-构建-node-类","link":"#_3-1-构建-node-类","children":[]},{"level":3,"title":"3.2 创建 BinaryTree 类","slug":"_3-2-创建-binarytree-类","link":"#_3-2-创建-binarytree-类","children":[]},{"level":3,"title":"3.3 编写插入函数 insert","slug":"_3-3-编写插入函数-insert","link":"#_3-3-编写插入函数-insert","children":[]},{"level":3,"title":"3.4 编写递归插入子树 _insert_recursive","slug":"_3-4-编写递归插入子树-insert-recursive","link":"#_3-4-编写递归插入子树-insert-recursive","children":[]},{"level":3,"title":"3.5 编写可遍历的 inorder","slug":"_3-5-编写可遍历的-inorder","link":"#_3-5-编写可遍历的-inorder","children":[]},{"level":3,"title":"3.6 实现中序遍历 _inorder_recursive","slug":"_3-6-实现中序遍历-inorder-recursive","link":"#_3-6-实现中序遍历-inorder-recursive","children":[]},{"level":3,"title":"3.7 主程序","slug":"_3-7-主程序","link":"#_3-7-主程序","children":[]},{"level":3,"title":"3.8 完整代码","slug":"_3-8-完整代码","link":"#_3-8-完整代码","children":[]}]}],"git":{"createdTime":1705215474000,"updatedTime":1705215474000,"contributors":[{"name":"AndersonHJB","email":"cleland1432803776@icloud.com","commits":1}]},"readingTime":{"minutes":5.83,"words":1749},"filePathRelative":"Python/Python-core-technology-and-practice/Casual-essay/01-binary-tree.md","localizedDate":"2023年8月27日","copyright":{"author":"AI悦创"}}');export{d as comp,y as data};
