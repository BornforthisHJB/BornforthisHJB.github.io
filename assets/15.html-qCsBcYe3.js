import{_ as n}from"./gzh-DnOBNg6W.js";import{_ as a}from"./zsxq-BcdwOI-_.js";import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as p,o}from"./app-BRhJJPGx.js";const t="/assets/5e15321d0001aad106400426-Dh1FsPuA.jpg",i="/assets/5e15327d0001af1904150408-D9J4l1Sg.png",r={};function c(F,s){return o(),e("div",null,s[0]||(s[0]=[p('<figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_1-归并排序原理" tabindex="-1"><a class="header-anchor" href="#_1-归并排序原理"><span>1. 归并排序原理</span></a></h2><p>先来看第一种高级排序算法：归并排序。“归并”一词出自《后汉书》，意为“合并”。</p><p>顾名思义，归并排序算法就是一个先把数列拆分为子数列，对子数列进行排序后，再把有序的子数列合并为完整的有序数列的算法。它实际上采用了分治的思想，我们会在后面文章中深度讲解分治思想。</p><p>归并排序的平均时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，最好情况下的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, 最坏情况下的时间复杂度也是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。它的空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，另外还是一个稳定的排序算法。</p><p>以升序排序为例，归并算法的流程就如下图所示。</p><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>原始数组是一个有八个数的无序数组。一次操作后，把八个数的数组分成两个四个数组成的无序数组。接下来的每次操作都是把无序数组不停分成两半，直到每个最小的数组里都只有一个元素为止。</p><p><strong><span style="color:orange;">当数组里只有一个元素时，这个数组必定是有序的。</span></strong></p><p>然后，程序开始把小的有序数组每两个合并成为大的有序数组。先是从两个 1 个数的数组合并成 2 个数的数组，再到 4 个数然后 8 个数。这时候，所有的有序数组全部合并完成，最后产生的最长的有序数组就排序完成了。</p><h2 id="_2-归并排序代码" tabindex="-1"><a class="header-anchor" href="#_2-归并排序代码"><span>2. 归并排序代码</span></a></h2><p>归并排序代码：</p><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" data-title="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">#归并排序</span></span>
<span class="line"><span style="color:#F8F8F2;">nums </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">8</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">7</span><span style="color:#F8F8F2;">]</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> MergeSort</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">num</span><span style="color:#F8F8F2;">): </span></span>
<span class="line"><span style="color:#F92672;">    if</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;">len</span><span style="color:#F8F8F2;">(num)</span><span style="color:#F92672;">&lt;=</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">): 				</span><span style="color:#88846F;">#递归边界条件</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#F8F8F2;"> num 				</span><span style="color:#88846F;">#到达边界时返回当前的子数组</span></span>
<span class="line"><span style="color:#F8F8F2;">    mid </span><span style="color:#F92672;">=</span><span style="color:#66D9EF;font-style:italic;"> int</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;">len</span><span style="color:#F8F8F2;">(num)</span><span style="color:#F92672;">/</span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">) 			</span><span style="color:#88846F;">#求出数组的中</span></span>
<span class="line"><span style="color:#F8F8F2;">    llist,rlist </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> MergeSort(num[:mid]),MergeSort(num[mid:])</span><span style="color:#88846F;">#调用函数分别为左右数组排序</span></span>
<span class="line"><span style="color:#F8F8F2;">    result </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []</span></span>
<span class="line"><span style="color:#F8F8F2;">    i,j </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span><span style="color:#F8F8F2;">,</span><span style="color:#AE81FF;">0</span></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(llist) </span><span style="color:#F92672;">and</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(rlist): </span><span style="color:#88846F;">#while循环用于合并两个有序数组</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> rlist[j]</span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;">llist[i]:</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(rlist[j])</span></span>
<span class="line"><span style="color:#F8F8F2;">            j </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(llist[i])</span></span>
<span class="line"><span style="color:#F8F8F2;">            i </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"><span style="color:#F8F8F2;">    result </span><span style="color:#F92672;">+=</span><span style="color:#F8F8F2;"> llist[i:]</span><span style="color:#F92672;">+</span><span style="color:#F8F8F2;">rlist[j:] 	</span><span style="color:#88846F;">#把数组未添加的部分加到结果数组末尾</span></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> result 					</span><span style="color:#88846F;">#返回已排序的数组</span></span>
<span class="line"><span style="color:#66D9EF;">print</span><span style="color:#F8F8F2;">(MergeSort(nums))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><p>运行程序，输出结果为：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">7</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">8</span><span style="color:#F8F8F2;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 MergeSort 函数中，首先进行的是边界条件判断。当传进函数的数组长度只有 1 时，每一个数独立存在于一个数组中，因此数组已经被分到最小。这时候，递归分解数组的任务已经完成，只需要把分解后的数组返回到上一层递归就可以了。</p><p>如果未排序数组的长度仍然大于 1，那么使用变量 mid 来存储数组最中间的下标，把未排序数组分成左右两个子数组。然后，新建两个数组，用于存储排好序的左右子数组。这里使用了递归的思想。我们只把 MergeSort 函数视为一个为列表排序的函数，尽管在 MergeSort 函数内部，也可以调用函数本身对两个子数组进行排序。</p><h2 id="_3-小结" tabindex="-1"><a class="header-anchor" href="#_3-小结"><span>3. 小结</span></a></h2><p>相比起初级排序算法，高级排序算法往往有更加复杂的逻辑，但也会有更高的时间或空间效率。其中有些高级排序算法是由前面小节中所讲的初级排序算法优化而来的。在处理大量数据时，被归类为高级的排序算法一般更加常用。</p><h2 id="_4-分步实现" tabindex="-1"><a class="header-anchor" href="#_4-分步实现"><span>4. 分步实现</span></a></h2><p>归并排序是一种分而治之的排序算法，其基本原理是将一个大列表分成两个小列表，然后将这两个小列表各自排序，最后将排序后的两个小列表归并成一个有序列表。</p><p>我们先从简单的部分开始，分解归并排序为以下步骤：</p><ol><li><p><strong>分解</strong>：如果列表中只有 0 个或 1 个元素，那么它已经是排序好的。如果列表中有 2 个或更多的元素，我们就把它分成两个小列表。</p></li><li><p><strong>解决</strong>：我们用归并排序法对两个小列表进行排序。</p></li><li><p><strong>合并</strong>：我们把两个排序好的小列表归并成一个大的，排序好的列表。</p></li></ol><p>现在我们来实现这个算法。首先，我们需要一个 <code>merge</code> 函数来合并两个已排序的列表：</p><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" data-title="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> merge</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">left</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">right</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#F8F8F2;">    result </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []</span></span>
<span class="line"><span style="color:#F8F8F2;">    i </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(left) </span><span style="color:#F92672;">and</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(right):</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> left[i] </span><span style="color:#F92672;">&lt;=</span><span style="color:#F8F8F2;"> right[j]:</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(left[i])</span></span>
<span class="line"><span style="color:#F8F8F2;">            i </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(right[j])</span></span>
<span class="line"><span style="color:#F8F8F2;">            j </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(left):</span></span>
<span class="line"><span style="color:#F8F8F2;">        result.append(left[i])</span></span>
<span class="line"><span style="color:#F8F8F2;">        i </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(right):</span></span>
<span class="line"><span style="color:#F8F8F2;">        result.append(right[j])</span></span>
<span class="line"><span style="color:#F8F8F2;">        j </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> result</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><p>这个函数做的就是：只要左边和右边的列表都有元素，就比较两边最小的元素并把它添加到结果列表中，然后将那边的索引+1。当左边或右边的列表没有元素时，就把另一边剩下的元素全部添加到结果列表中。</p><p>然后我们需要<code>merge_sort</code>函数来实现分解和解决步骤：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> merge_sort</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">lst</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#F92672;">    if</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(lst) </span><span style="color:#F92672;">&lt;=</span><span style="color:#AE81FF;"> 1</span><span style="color:#F8F8F2;">:  </span><span style="color:#88846F;"># 基线条件：为空或只包含一个元素的列表总是有序的</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#F8F8F2;"> lst</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2;">    mid </span><span style="color:#F92672;">=</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(lst) </span><span style="color:#F92672;">//</span><span style="color:#AE81FF;"> 2</span></span>
<span class="line"><span style="color:#F8F8F2;">    left </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> merge_sort(lst[:mid])  </span><span style="color:#88846F;"># 递归地排序左半部分</span></span>
<span class="line"><span style="color:#F8F8F2;">    right </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> merge_sort(lst[mid:])  </span><span style="color:#88846F;"># 递归地排序右半部分</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> merge(left, right)  </span><span style="color:#88846F;"># 合并两个有序列表</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数首先检查基线条件：如果列表为空或只包含一个元素，就返回列表本身，因为这样的列表总是有序的。否则，它将列表分成两半，并递归地对它们进行排序，然后把排序好的两个列表归并在一起。</p><p>那么现在你就可以测试你的归并排序算法了：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;">print</span><span style="color:#F8F8F2;">(merge_sort([</span><span style="color:#AE81FF;">38</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">27</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">43</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">9</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">82</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">10</span><span style="color:#F8F8F2;">]))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个程序将输出：<code>[3, 9, 10, 27, 38, 43, 82]</code>，这就是原列表的排序版本。</p><hr><p>让我们从归并排序的基本概念开始。归并排序是一种典型的分治算法，它的基本思想是：将一个大问题分解成小的子问题来解决。小的子问题解决了，那么原来的大问题也就解决了。在归并排序中，这个大问题就是“如何排序一个序列”，小问题就是“如何排序一个子序列”，并且，这个子序列相对于原序列来说，规模小了一半。</p><p>以下是实现归并排序的Python代码及其详细注释。</p><p>首先，我们定义了一个名为<code>merge</code>的函数，该函数将两个已经排序的列表（我们称之为 left 和 right）合并为一个大的排序列表。</p><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" data-title="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> merge</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">left</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">right</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#F8F8F2;">    result </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []  </span><span style="color:#88846F;"># 创建一个空列表，用于存放排序结果</span></span>
<span class="line"><span style="color:#F8F8F2;">    i </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span><span style="color:#88846F;">  # 初始化两个指针 i 和 j，分别指向 left 和 right 的第一个元素</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 当 i 和 j 都在各自的列表范围内时</span></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(left) </span><span style="color:#F92672;">and</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(right):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果左边的元素小于或等于右边的元素</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> left[i] </span><span style="color:#F92672;">&lt;=</span><span style="color:#F8F8F2;"> right[j]:</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(left[i])  </span><span style="color:#88846F;"># 将左边的元素添加到结果列表中</span></span>
<span class="line"><span style="color:#F8F8F2;">            i </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span><span style="color:#88846F;">  # 将指针 i 向右移动一位，以指向下一个元素</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:  </span><span style="color:#88846F;"># 如果左边的元素大于右边的元素</span></span>
<span class="line"><span style="color:#F8F8F2;">            result.append(right[j])  </span><span style="color:#88846F;"># 将右边的元素添加到结果列表中</span></span>
<span class="line"><span style="color:#F8F8F2;">            j </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span><span style="color:#88846F;">  # 将指针 j 向右移动一位，以指向下一个元素</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 当 i 或 j 中的任何一个超出各自的列表范围时，退出循环</span></span>
<span class="line"><span style="color:#88846F;">    # 如果左边列表还有剩余元素，则全部追加到结果列表中</span></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(left):</span></span>
<span class="line"><span style="color:#F8F8F2;">        result.append(left[i])</span></span>
<span class="line"><span style="color:#F8F8F2;">        i </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 如果右边列表还有剩余元素，则全部追加到结果列表中</span></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">&lt;</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(right):</span></span>
<span class="line"><span style="color:#F8F8F2;">        result.append(right[j])</span></span>
<span class="line"><span style="color:#F8F8F2;">        j </span><span style="color:#F92672;">+=</span><span style="color:#AE81FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> result  </span><span style="color:#88846F;"># 返回排序后的结果列表</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><p>然后，我们实现<code>merge_sort</code>函数，它是一个递归函数。给定一个列表，如果列表只有一个或零个元素，那么这个列表已经排序好了，我们直接返回这个列表。否则，我们将列表分为两部分，然后对每一部分递归地调用<code>merge_sort</code>，最后将排序好的两部分使用<code>merge</code>函数合并。</p><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" data-title="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> merge_sort</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">lst</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">    # 如果列表只有一个元素或者没有元素，那么这个列表已经是排序好的</span></span>
<span class="line"><span style="color:#F92672;">    if</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(lst) </span><span style="color:#F92672;">&lt;=</span><span style="color:#AE81FF;"> 1</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#F92672;">        return</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2;"> lst</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 找到列表的中间位置</span></span>
<span class="line"><span style="color:#F8F8F2;">    mid </span><span style="color:#F92672;">=</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(lst) </span><span style="color:#F92672;">//</span><span style="color:#AE81FF;"> 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 对列表的左半部分进行排序</span></span>
<span class="line"><span style="color:#F8F8F2;">    left </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> merge_sort(lst[:mid])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 对列表的右半部分进行排序</span></span>
<span class="line"><span style="color:#F8F8F2;">    right </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> merge_sort(lst[mid:])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 将排序好的两部分合并</span></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> merge(left, right)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><p>现在，你可以调用<code>merge_sort</code>函数来对一个列表进行排序。</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;">print</span><span style="color:#F8F8F2;">(merge_sort([</span><span style="color:#AE81FF;">38</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">27</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">43</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">9</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">82</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">10</span><span style="color:#F8F8F2;">]))</span></span>
<span class="line"><span style="color:#88846F;"># 输出: [3, 9, 10, 27, 38, 43, 82]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是归并排序的完整实现，以及每行代码的详细注释。希望这些信息对你有所帮助。如果你对任何部分有疑问，请随时向我提问。</p><p>欢迎关注我公众号：AI悦创，有更多更好玩的等你发现！</p><details class="hint-container details"><summary>公众号：AI悦创【二维码】</summary><figure><img src="`+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></details><div class="hint-container info"><p class="hint-container-title">AI悦创·编程一对一</p><p>AI悦创·推出辅导班啦，包括「Python 语言辅导班、C++ 辅导班、java 辅导班、算法/数据结构辅导班、少儿编程、pygame 游戏开发」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践等。当然，还有线下线上摄影课程、Photoshop、Premiere 一对一教学、QQ、微信在线，随时响应！微信：Jiabcdefh</p><p>C++ 信息奥赛题解，长期更新！长期招收一对一中小学信息奥赛集训，莆田、厦门地区有机会线下上门，其他地区线上。微信：Jiabcdefh</p><p>方法一：<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=1432803776&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener noreferrer">QQ</a></p><p>方法二：微信：Jiabcdefh</p></div><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',46)]))}const h=l(r,[["render",c],["__file","15.html.vue"]]),u=JSON.parse('{"path":"/Python/Python-core-technology-and-practice/Algorithm/15.html","title":"15 排序八大金刚-归并排序","lang":"zh-CN","frontmatter":{"title":"15 排序八大金刚-归并排序","icon":"shujujiegou-01","date":"2023-06-15T22:23:53.000Z","author":"AI悦创","isOriginal":true,"category":"Python 算法科普指南","tag":["Python 算法科普指南"],"sticky":false,"star":false,"article":true,"timeline":true,"image":false,"navbar":true,"sidebarIcon":true,"headerDepth":5,"comment":true,"lastUpdated":true,"editLink":false,"backToTop":true,"toc":true,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"1. 归并排序原理","slug":"_1-归并排序原理","link":"#_1-归并排序原理","children":[]},{"level":2,"title":"2. 归并排序代码","slug":"_2-归并排序代码","link":"#_2-归并排序代码","children":[]},{"level":2,"title":"3. 小结","slug":"_3-小结","link":"#_3-小结","children":[]},{"level":2,"title":"4. 分步实现","slug":"_4-分步实现","link":"#_4-分步实现","children":[]}],"git":{"createdTime":1705215474000,"updatedTime":1705215474000,"contributors":[{"name":"AndersonHJB","email":"cleland1432803776@icloud.com","commits":1}]},"readingTime":{"minutes":8.53,"words":2559},"filePathRelative":"Python/Python-core-technology-and-practice/Algorithm/15.md","localizedDate":"2023年6月15日","copyright":{"author":"AI悦创"}}');export{h as comp,u as data};
