import{_ as a}from"./gzh-DnOBNg6W.js";import{_ as n}from"./zsxq-BcdwOI-_.js";import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as e,o}from"./app-D50Ssarp.js";const t="/assets/5e12922c0001eb8d06400426-x77hf8ER.jpg",i="/assets/5e0da5e40001128405930216-C4bE0WqY.png",r="/assets/5e0da60200013df805190218-BU_AobZy.png",c="/assets/5e0da6180001915d06010232-D1XguP_b.png",F="/assets/5e0da6780001720405990083-Cghue1S4.png",m="/assets/5e0da6dc0001459d05950086-CkGJuF9f.png",d="/assets/5e0da6d500014d5b05960091-CkXUm4W9.png",y="/assets/5e0da6cf000182fc05890092-Z8j5Zenb.png",g="/assets/5e0da6c800010af805910090-DPU9y5sb.png",u="/assets/5e0da6c100019e9a05900082-CjDaf2uC.png",h="/assets/5e0da6b80001864a06050091-DzW-rbwT.png",f={};function v(b,s){return o(),p("div",null,s[0]||(s[0]=[e('<figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>选择排序表示从无序的数组中，每次选择最小或最大的数据，从无序数组中放到有序数组的末尾，以达到排序的效果。</p><p>选择排序的平均时间复杂度，最好情况下的时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，最坏情况下的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。另外，它是一个不稳定的排序算法。</p><h2 id="_1-选择排序" tabindex="-1"><a class="header-anchor" href="#_1-选择排序"><span>1. 选择排序</span></a></h2><p>选择排序的过程很容易理解。如下图所示，我们仍以递增排序的算法为例，先遍历未排序的数组，找到最小的元素。然后，把最小的元素从未排序的数组中删除，添加到有序数组的末尾。</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因为最小的元素是1，所以1被添加到仍为空的有序数组末尾。</p><p>如下图所示，我们继续对剩余元素进行遍历。这次，最小的元素是2。我们把它添加到已排序的数组末尾。由于已在有序数组中的元素必定小于未排序数组中的所有元素，所以这步操作是正确无误的。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如下图所示，重复上述步骤，当未排序数组中只剩下一个元素时，把它添加到已排序的数组末尾，整个数组的排序就完成了。</p><figure><img src="'+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>采用图中的思路，以下代码将数组 nums 进行正序排序。</p><p>选择排序代码（基础版）：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#F8F8F2;">nums </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">8</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">7</span><span style="color:#F8F8F2;">]</span></span>
<span class="line"><span style="color:#F8F8F2;">res </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []  </span><span style="color:#88846F;"># 用于存储已排序元素的数组</span></span>
<span class="line"><span style="color:#F92672;">while</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(nums):  </span><span style="color:#88846F;"># 当未排序数组内还有元素时，重复执行选择最小数的代码</span></span>
<span class="line"><span style="color:#F8F8F2;">    minInd </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span><span style="color:#88846F;">  # 初始化存储最小数下标的变量，默认为第一个数</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">in</span><span style="color:#66D9EF;"> range</span><span style="color:#F8F8F2;">(</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#66D9EF;">len</span><span style="color:#F8F8F2;">(nums)):</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> (nums[i] </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> nums[minInd]):  </span><span style="color:#88846F;"># 更新最小数的下标</span></span>
<span class="line"><span style="color:#F8F8F2;">            minInd </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> i</span></span>
<span class="line"><span style="color:#F8F8F2;">    temp </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> nums[minInd]</span></span>
<span class="line"><span style="color:#F8F8F2;">    nums.pop(minInd)  </span><span style="color:#88846F;"># 把最小数从未排序数组中删除</span></span>
<span class="line"><span style="color:#F8F8F2;">    res.append(temp)  </span><span style="color:#88846F;"># 把最小数插入到已排序数组的末尾</span></span>
<span class="line"><span style="color:#66D9EF;">print</span><span style="color:#F8F8F2;">(res)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行程序，输出结果为：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">7</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">8</span><span style="color:#F8F8F2;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>代码中，最外层的 while 循环用于判断是否所有的元素都已经进入有序的数组，从而确定排序是否已经完成。如果无序数组中已经没有元素，说明排序已经完成。</p><p>在开始遍历无序数组之前，先初始化记录最小值下标的变量为 0，所以 for 循环可以从第二个元素，也就是下标为1的元素开始遍历。找到最小值后，用 temp 存储最小数的值。执行 pop 函数把最小数从原数组中删除，这样它不会影响下一步的选择。最后，用 append 把 temp 存储的元素插入到有序数组末尾。</p><h2 id="_2-选择排序改进版" tabindex="-1"><a class="header-anchor" href="#_2-选择排序改进版"><span>2. 选择排序改进版</span></a></h2><p>虽然这样实现排序较为直观，代码逻辑也比较简单，但可以注意到，这样实现插入排序需要两个同样大小数组的空间。如果要处理的数据量较大，这样的算法会浪费资源。所以，我们要对算法做一些改动，使选择排序能够在同一个数组内完成。同样地，我们用图片来展示这个过程。</p><p>首先，如下图所示，在未排序的数组中找到最小的数1。</p><figure><img src="`+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此时，它是我们找到的第一个最小数。如下图所示，我们把它与数组的第一个元素交换。</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如下图所示，这时候，数组中的第一个位置就成为了有序数据的一部分。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来，如下图所示，由于第一个元素已经有序了，所以我们只需要在它之后的数组中搜索最小值。这一趟搜索过后，最小值是 2，所以把 2 和第二个元素交换位置。</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如下图所示，2 和第二个元素交换位置后，第二个位置就成为了这个有序数组的一部分。</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来，如下图所示，继续重复以上步骤，直到所有元素都被加入到有序数组中。下面给出了确定第三小的数的过程。</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如下图，当所有元素都加入有序数组后，排序就完成了。</p><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用这样的思路，我们可以使用代码实现选择排序。</p><p>选择排序代码（原地版）：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#F8F8F2;">nums </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">8</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">7</span><span style="color:#F8F8F2;">]</span></span>
<span class="line"><span style="color:#F92672;">for</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">in</span><span style="color:#66D9EF;"> range</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;">len</span><span style="color:#F8F8F2;">(nums) </span><span style="color:#F92672;">-</span><span style="color:#AE81FF;"> 1</span><span style="color:#F8F8F2;">):  </span><span style="color:#88846F;"># 更新有序数组的末尾位置</span></span>
<span class="line"><span style="color:#F8F8F2;">    minInd </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> i</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> j </span><span style="color:#F92672;">in</span><span style="color:#66D9EF;"> range</span><span style="color:#F8F8F2;">(i, </span><span style="color:#66D9EF;">len</span><span style="color:#F8F8F2;">(nums)):  </span><span style="color:#88846F;"># 找出未排序数组中最小值的下标</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> nums[j] </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> nums[minInd]:</span></span>
<span class="line"><span style="color:#F8F8F2;">            minInd </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> j</span></span>
<span class="line"><span style="color:#F8F8F2;">    nums[i], nums[minInd] </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> nums[minInd], nums[i]  </span><span style="color:#88846F;"># 把最小值加到有序数组末尾</span></span>
<span class="line"><span style="color:#66D9EF;">print</span><span style="color:#F8F8F2;">(nums)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行程序，输出结果为：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">7</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">8</span><span style="color:#F8F8F2;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在程序中，第一个 for 循环中的i代表了有序数组之后的第一个位置，也就是未排序数组中的第一个位置。随后，再使用一个 for 循环，在未排序数组中找到最小值的下标。首先，把最小值下标 minInd 初始化为未排序数组中第一个元素的下标。随后，遍历整个数组，遇到比目前的最小值更小的元素时，更新下标即可。找出最小值后，把它和未排序数组中的第一个元素交换位置，这时它就成为了有序数组中的最后一个元素。</p><h2 id="_3-小结" tabindex="-1"><a class="header-anchor" href="#_3-小结"><span>3. 小结</span></a></h2><p>本节介绍了选择排序算法，在其他一些编程语言中，不能像 Python 一样使用 pop、insert 等函数对数组进行操作。插入一个数时，需要把插入位置及后面的所有元素都向后移动一位。这时候，本小节中的原地版算法优势更加明显。</p><p>欢迎关注我公众号：AI悦创，有更多更好玩的等你发现！</p><details class="hint-container details"><summary>公众号：AI悦创【二维码】</summary><figure><img src="`+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></details><div class="hint-container info"><p class="hint-container-title">AI悦创·编程一对一</p><p>AI悦创·推出辅导班啦，包括「Python 语言辅导班、C++ 辅导班、java 辅导班、算法/数据结构辅导班、少儿编程、pygame 游戏开发」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践等。当然，还有线下线上摄影课程、Photoshop、Premiere 一对一教学、QQ、微信在线，随时响应！微信：Jiabcdefh</p><p>C++ 信息奥赛题解，长期更新！长期招收一对一中小学信息奥赛集训，莆田、厦门地区有机会线下上门，其他地区线上。微信：Jiabcdefh</p><p>方法一：<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=1432803776&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener noreferrer">QQ</a></p><p>方法二：微信：Jiabcdefh</p></div><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',46)]))}const k=l(f,[["render",v],["__file","13.html.vue"]]),z=JSON.parse('{"path":"/Python/Python-core-technology-and-practice/Algorithm/13.html","title":"13 排序八大金刚-选择排序","lang":"zh-CN","frontmatter":{"title":"13 排序八大金刚-选择排序","icon":"shujujiegou-01","date":"2023-06-07T22:08:20.000Z","author":"AI悦创","isOriginal":true,"category":"Python 算法科普指南","tag":["Python 算法科普指南"],"sticky":false,"star":false,"article":true,"timeline":true,"image":false,"navbar":true,"sidebarIcon":true,"headerDepth":5,"comment":true,"lastUpdated":true,"editLink":false,"backToTop":true,"toc":true,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"1. 选择排序","slug":"_1-选择排序","link":"#_1-选择排序","children":[]},{"level":2,"title":"2. 选择排序改进版","slug":"_2-选择排序改进版","link":"#_2-选择排序改进版","children":[]},{"level":2,"title":"3. 小结","slug":"_3-小结","link":"#_3-小结","children":[]}],"git":{"createdTime":1705215474000,"updatedTime":1705215474000,"contributors":[{"name":"AndersonHJB","email":"cleland1432803776@icloud.com","commits":1}]},"readingTime":{"minutes":5.87,"words":1762},"filePathRelative":"Python/Python-core-technology-and-practice/Algorithm/13.md","localizedDate":"2023年6月7日","copyright":{"author":"AI悦创"}}');export{k as comp,z as data};
