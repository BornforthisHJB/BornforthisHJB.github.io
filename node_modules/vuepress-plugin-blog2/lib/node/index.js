import{createPage as T,preparePageComponent as O,preparePageData as B,preparePagesComponents as S,preparePagesData as V,preparePagesRoutes as j}from"@vuepress/core";import{watch as K}from"chokidar";import{removeLeadingSlash as D}from"@vuepress/shared";import{Logger as A}from"vuepress-shared/node";const n=new A("vuepress-plugin-blog2"),x=(t,v)=>{const f={};return Object.keys({"/":{},...v.options.locales}).forEach(l=>{f[l]=[]}),v.pages.filter(t).forEach(l=>{f[l.pathLocale].push(l)}),f},G=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogCategory)
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ categoryMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
  });

`,H=(t,v,f,l=!1)=>{const{category:M=[],slugify:m=e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=v;return Promise.all(M.map(async({key:e,getter:i,sorter:a=()=>-1,path:o="/:key/",layout:c="Layout",frontmatter:d=()=>({}),itemPath:g="/:key/:name/",itemLayout:k="Layout",itemFrontmatter:y=()=>({})},p)=>{if(typeof e!="string"||!e)return n.error(`Invalid 'key' option ${e} in 'category[${p}]'`),null;if(typeof i!="function")return n.error(`Invalid 'getter' option in 'category[${p}]', it should be a function!`),null;t.env.isDebug&&n.info(`Generating ${e} category.
`);const _={},$=[],w=typeof g=="function"?g:r=>(g||"").replace(/:key/g,m(e)).replace(/:name/g,m(r));for(const r in f){if(o){const u=`${r}${D(o.replace(/:key/g,m(e)))}`,h=await T(t,{path:u,frontmatter:{...d(r),blog:{type:"category",key:e},layout:c}}),s=t.pages.findIndex(({path:E})=>E===u);s===-1?t.pages.push(h):t.pages[s].key!==h.key&&(t.pages.splice(s,1,h),l&&n.warn(`Overriding existed path ${u}`)),$.push(h.key),_[r]={path:h.path,map:{}}}else _[r]={path:"",map:{}};const{map:b}=_[r],P={};for(const u of f[r]){const h=i(u);for(const s of h){if(!b[s]){const E=w(s);if(E){const U=`${r}${D(E)}`,R=await T(t,{path:`${r}${D(E)}`,frontmatter:{...y(s,r),blog:{type:"category",name:s,key:e},layout:k}}),I=t.pages.findIndex(({path:N})=>N===U);I===-1?t.pages.push(R):t.pages[I].key!==R.key&&(t.pages.splice(I,1,R),l&&n.warn(`Overriding existed path ${U}`)),$.push(R.key),b[s]={path:R.path,keys:[]}}else b[s]={path:"",keys:[]};P[s]=[]}P[s].push(u)}}for(const u in P)b[u].keys=P[u].sort(a).map(({key:h})=>h);if(t.env.isDebug){let u=`Route ${r} in ${e} category:
`;for(const h in b){const{path:s,keys:E}=b[h];u+=`name: ${h}; ${s?`path: ${s}; `:""}items: ${E.length}
`}n.info(u)}}return{key:e,map:_,pageKeys:$}})).then(async e=>{const i={},a=[];return e.filter(o=>o!==null).forEach(({key:o,map:c,pageKeys:d})=>{i[o]=c,a.push(...d)}),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(i)};
${t.env.isDev?G:""}
`),t.env.isDebug&&n.info("All categories generated."),a})},J=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogType)
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ typeMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
  });
`,L=(t,v,f,l=!1)=>{const{type:M=[],slugify:m=e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=v;return Promise.all(M.map(async({key:e,sorter:i=()=>-1,filter:a=()=>!0,path:o="/:key/",layout:c="Layout",frontmatter:d=()=>({})},g)=>{if(typeof e!="string"||!e)return n.error(`Invalid 'key' option ${e} in 'category[${g}]'`),null;const k={},y=[];t.env.isDebug&&n.info(`Generating ${e} type.
`);for(const p in f){const _=f[p].filter(a).sort(i).map(({key:$})=>$);if(o){const $=`${p}${D(m(o.replace(/:key/g,e)))}`,w=await T(t,{path:$,frontmatter:{...d(p),blog:{type:"type",key:e},layout:c}}),r=t.pages.findIndex(({path:b})=>b===$);r===-1?t.pages.push(w):t.pages[r].key!==w.key&&(t.pages.splice(r,1,w),l&&n.warn(`Overriding existed path ${$}`)),y.push(w.key),k[p]={path:w.path,keys:_},t.env.isDebug&&n.info(`Route ${p} in ${e} type: path: ${w.path}; items: ${_.length}
`)}else k[p]={path:"",keys:_},t.env.isDebug&&n.info(`Route ${p} in ${e} type: items: ${_.length}
`)}return{key:e,map:k,pageKeys:y}})).then(async e=>{const i={},a=[];return e.filter(o=>o!==null).forEach(({key:o,map:c,pageKeys:d})=>{i[o]=c,a.push(...d)}),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(i)};
${t.env.isDev?J:""}
`),t.env.isDebug&&n.info("All types generated."),a})},C=t=>v=>{const{getInfo:f=()=>({}),filter:l=e=>Boolean(e.filePathRelative)&&!e.frontmatter.home,metaScope:M="_blog"}=t;let m=[];return v.env.isDebug&&n.info(`Options: ${t.toString()}`),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:M}),extendsPage:e=>{l(e)&&(e.routeMeta={...M===""?f(e):{[M]:f(e)},...e.routeMeta})},onInitialized:e=>{const i=x(l,e);return Promise.all([H(e,t,i,!0).then(a=>{m.push(...a)}),L(e,t,i,!0).then(a=>{m.push(...a)})]).then(()=>{e.env.isDebug&&n.info("temp file generated")})},onWatched:(e,i)=>{if(t.hotReload){const a=K("pages/**/*.js",{cwd:e.dir.temp(),ignoreInitial:!0}),o=()=>{const c=[],d=x(l,e);return Promise.all([H(e,t,d).then(g=>{c.push(...g)}),L(e,t,d).then(g=>{c.push(...g)})]).then(async()=>{const g=m.filter(y=>!c.includes(y)),k=c.filter(y=>!m.includes(y));k.length&&(e.env.isDebug&&n.info(`New pages detected: ${k.toString()}`),await Promise.all(k.map(async y=>{await O(e,e.pages.find(({key:p})=>p===y)),await B(e,e.pages.find(({key:p})=>p===y))}))),g.length&&(e.env.isDebug&&n.info(`Removing following pages: ${g.toString()}`),g.forEach(y=>{e.pages.splice(e.pages.findIndex(({key:p})=>p===y),1)})),(g.length||k.length)&&(await S(e),await V(e),await j(e)),m=c,e.env.isDebug&&n.info("temp file updated")})};a.on("add",()=>{o()}),a.on("change",()=>{o()}),a.on("unlink",()=>{o()}),i.push(a)}}}};export{C as blogPlugin,C as default};
//# sourceMappingURL=index.js.map
